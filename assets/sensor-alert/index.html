<!DOCTYPE html>
<!--
    SensorAlert: Acoustic Radar Scanner
    ¬© 2025 Yixuan Gao. All rights reserved.
    
    Real-time ultrasonic privacy protection system
    Original work created by Yixuan Gao 
    
    This software is protected by copyright law.
    Unauthorized reproduction or distribution is prohibited.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ°Ô∏è Acoustic FMCW Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2e2e2e 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            color: #00ff41;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }

        .header p {
            color: #888;
            font-size: 1.1em;
        }

        .control-panel {
            background: rgba(46, 46, 46, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 65, 0.2);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            align-items: center;
        }

        .status-section h3 {
            color: #00ff41;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .status-text {
            color: #888;
            font-size: 1.1em;
        }

        .threat-section {
            text-align: center;
        }

        .threat-level {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
            color: #00ff41;
            text-shadow: 0 0 10px currentColor;
        }

        .threat-bar {
            width: 100%;
            height: 15px;
            background: #1e1e1e;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            border: 1px solid #333;
        }

        .threat-fill {
            height: 100%;
            width: 0%;
            background: #00ff41;
            border-radius: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px currentColor;
        }

        .button-section {
            text-align: right;
        }

        .btn {
            padding: 15px 25px;
            font-size: 1.1em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 0 5px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: #00ff41;
            color: #000;
        }

        .btn-primary:hover {
            background: #00cc33;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 65, 0.4);
        }

        .btn-danger {
            background: #ff4141;
            color: white;
        }

        .btn-danger:hover {
            background: #cc3333;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #3e3e3e;
            color: white;
        }

        .btn-secondary:hover {
            background: #4e4e4e;
            transform: translateY(-2px);
        }

        .visualization {
            background: rgba(46, 46, 46, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(0, 255, 65, 0.2);
        }

        .viz-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .viz-panel {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #333;
        }

        .viz-title {
            color: #00ff41;
            font-size: 1.1em;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 200px;
            border-radius: 5px;
        }

        .frequency-display {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #333;
            margin-top: 15px;
        }

        .freq-bars {
            display: flex;
            height: 100px;
            align-items: end;
            gap: 2px;
            margin-top: 15px;
        }

        .freq-bar {
            flex: 1;
            background: #00ff41;
            border-radius: 2px 2px 0 0;
            min-height: 2px;
            opacity: 0.7;
            transition: all 0.1s ease;
        }

        .log-panel {
            background: rgba(46, 46, 46, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(0, 255, 65, 0.2);
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .log-content {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            border: 1px solid #333;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
        }

        .log-info { color: #00ff41; }
        .log-warning { color: #ffaa00; }
        .log-error { color: #ff4141; }
        .log-detection { 
            color: #ff00ff; 
            background: rgba(255, 0, 255, 0.1);
            font-weight: bold;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid #333;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #00ff41;
            display: block;
        }

        .stat-label {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .permission-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2e2e2e;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            border: 2px solid #00ff41;
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.3);
        }

        .modal-content h2 {
            color: #00ff41;
            margin-bottom: 20px;
        }

        .modal-content p {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                text-align: center;
            }

            .viz-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .header h1 {
                font-size: 2em;
            }

            .button-section {
                text-align: center;
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .hidden {
            display: none;
        }

        .footer {
            background: rgba(46, 46, 46, 0.6);
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            text-align: center;
            border: 1px solid rgba(0, 255, 65, 0.1);
        }

        .copyright {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .copyright strong {
            color: #00ff41;
        }

        .author-info {
            color: #666;
            font-size: 0.8em;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è Acoustic Radar Scanner</h1>
            <p>Real-time ultrasonic privacy protection for your device</p>
        </div>

        <div class="control-panel">
            <div class="controls-grid">
                <div class="status-section">
                    <h3>üì° System Status</h3>
                    <div class="status-text" id="statusText">Ready to scan</div>
                    <div class="status-text" id="deviceInfo" style="font-size: 0.9em; margin-top: 5px;"></div>
                </div>

                <div class="threat-section">
                    <h3>‚ö†Ô∏è Threat Level</h3>
                    <div class="threat-level" id="threatLevel">Safe</div>
                    <div class="threat-bar">
                        <div class="threat-fill" id="threatFill"></div>
                    </div>
                    <div style="font-size: 0.9em; color: #888; margin-top: 5px;" id="threatScore">Score: 0/10</div>
                </div>

                <div class="button-section">
                    <button class="btn btn-primary" id="scanBtn" onclick="toggleScanning()">
                        üîç Start Scan
                    </button>
                    <button class="btn btn-secondary" onclick="clearLog()">Clear</button>
                    <button class="btn btn-secondary" onclick="exportLog()">Export</button>
                </div>
            </div>
        </div>

        <div class="visualization">
            <h3 style="color: #00ff41; margin-bottom: 20px;">üìä Real-time Analysis</h3>
            
            <div class="viz-grid">
                <div class="viz-panel">
                    <div class="viz-title">Spectrogram (0-24 kHz)</div>
                    <canvas id="spectrogramCanvas"></canvas>
                </div>
                
                <div class="viz-panel">
                    <div class="viz-title">Ultrasonic Power (18-22 kHz)</div>
                    <canvas id="powerCanvas"></canvas>
                </div>
            </div>

            <div class="frequency-display">
                <div class="viz-title">Live Frequency Analysis</div>
                <div class="freq-bars" id="freqBars"></div>
                <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 0.8em; color: #888;">
                    <span>0 Hz</span>
                    <span>12 kHz</span>
                    <span>24 kHz</span>
                </div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <span class="stat-value" id="detectionCount">0</span>
                <div class="stat-label">Detections</div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="scanTime">00:00</span>
                <div class="stat-label">Scan Time</div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="avgPower">-‚àû</span>
                <div class="stat-label">Avg Power (dB)</div>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="peakFreq">--</span>
                <div class="stat-label">Peak Frequency</div>
            </div>
        </div>

        <div class="log-panel">
            <div class="log-header">
                <h3 style="color: #00ff41;">üìù Detection Log</h3>
                <div style="font-size: 0.9em; color: #888;">Live monitoring active</div>
            </div>
            <div class="log-content" id="logContent">
                <div class="log-entry log-info">[Ready] Acoustic FMCW Scanner initialized</div>
                <div class="log-entry log-info">[Ready] Click 'Start Scan' to begin monitoring</div>
            </div>
        </div>

        <!-- Copyright Footer -->
        <div class="footer">
            <div class="copyright">
                <strong>¬© 2025 Yixuan Gao. All rights reserved.</strong>
            </div>
            <div class="author-info">
                SensorAlert: Acoustic Radar Scanner | Original work by Yixuan Gao, Cornell University
            </div>
        </div>
    </div>

    <!-- Permission Modal -->
    <div class="permission-modal hidden" id="permissionModal">
        <div class="modal-content">
            <h2>üé§ Microphone Access Required</h2>
            <p>This scanner needs microphone access to detect ultrasonic signals that might be used for acoustic tracking or surveillance.</p>
            <p><strong>Your privacy is protected:</strong> All audio processing happens locally in your browser. No data is sent to any servers.</p>
            <button class="btn btn-primary" onclick="requestMicPermission()">Grant Permission</button>
        </div>
    </div>

    <script>
        /*
         * SensorAlert: Acoustic FMCW Scanner
         * ¬© 2025 Yixuan Gao. All rights reserved.
         * 
         * Real-time ultrasonic privacy protection system
         * Advanced pattern detection and threat assessment algorithms
         * 
         * This code is the original work of Yixuan Gao.
         * Unauthorized reproduction or distribution is prohibited.
         */

        // Application state
        let isScanning = false;
        let audioContext = null;
        let microphone = null;
        let analyser = null;
        let scriptProcessor = null;
        let startTime = null;
        let detectionCount = 0;
        let detectionLog = [];
        let powerHistory = [];
        let spectrogramData = [];

        // Audio settings
        const SAMPLE_RATE = 48000;
        const FFT_SIZE = 2048;
        const ULTRASONIC_MIN = 18000;
        const ULTRASONIC_MAX = 22000;
        
        // Simplified pattern detection settings
        const ANALYSIS_WINDOW = 2000;        // 5ÁßíÂàÜÊûêÁ™óÂè£
        const MIN_FREQUENCY = 10000;         // Âè™Áúã10kHz‰ª•‰∏ä
        const FRAME_RATE = 20;               // ÊØèÁßí20Â∏ßÂàÜÊûê
        const PATTERN_THRESHOLD = 0.5;      // Áõ∏‰ººÂ∫¶ÈòàÂÄº70%
        const MIN_REPEATS = 3;               // Ëá≥Â∞ë3Ê¨°ÈáçÂ§çÊâçÊä•Ë≠¶
        
        // Pattern detection buffers
        let spectrumHistory = [];            // Â≠òÂÇ®È¢ëË∞±ÂéÜÂè≤ 
        let patternDetectionActive = false;

        // Canvas contexts
        let spectrogramCtx, powerCtx;

        // Initialize when page loads
        window.addEventListener('load', function() {
            initializeCanvases();
            createFrequencyBars();
            logMessage('System initialized. Ready to scan.', 'info');
            updateDeviceInfo();
        });

        function initializeCanvases() {
            const spectrogramCanvas = document.getElementById('spectrogramCanvas');
            const powerCanvas = document.getElementById('powerCanvas');
            
            spectrogramCtx = spectrogramCanvas.getContext('2d');
            powerCtx = powerCanvas.getContext('2d');
            
            // Set canvas size
            spectrogramCanvas.width = spectrogramCanvas.offsetWidth;
            spectrogramCanvas.height = 200;
            powerCanvas.width = powerCanvas.offsetWidth;
            powerCanvas.height = 200;
        }

        function createFrequencyBars() {
            const freqBars = document.getElementById('freqBars');
            freqBars.innerHTML = '';
            
            for (let i = 0; i < 64; i++) {
                const bar = document.createElement('div');
                bar.className = 'freq-bar';
                bar.style.height = '2px';
                freqBars.appendChild(bar);
            }
        }

        async function requestMicPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: SAMPLE_RATE,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                // Stop the stream immediately - we just needed permission
                stream.getTracks().forEach(track => track.stop());
                
                document.getElementById('permissionModal').classList.add('hidden');
                logMessage('Microphone permission granted', 'info');
                updateDeviceInfo();
                
            } catch (error) {
                logMessage('Microphone permission denied: ' + error.message, 'error');
            }
        }

        async function updateDeviceInfo() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                document.getElementById('deviceInfo').textContent = 
                    `Found ${audioInputs.length} audio input device(s)`;
            } catch (error) {
                document.getElementById('deviceInfo').textContent = 'Cannot access device info';
            }
        }

        async function toggleScanning() {
            if (!isScanning) {
                await startScanning();
            } else {
                stopScanning();
            }
        }

        async function startScanning() {
            try {
                // Check if we have permission
                const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
                if (permissionStatus.state === 'denied') {
                    document.getElementById('permissionModal').classList.remove('hidden');
                    return;
                }

                // Get microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: SAMPLE_RATE,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });

                // Create audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                
                // Configure analyser
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0.1;
                
                // Connect audio nodes
                microphone.connect(analyser);
                
                // Start processing
                isScanning = true;
                startTime = Date.now();
                
                // Update UI
                const scanBtn = document.getElementById('scanBtn');
                scanBtn.textContent = '‚è∏ Stop Scan';
                scanBtn.className = 'btn btn-danger';
                
                document.getElementById('statusText').textContent = 'Scanning... Listening for ultrasonic signals';
                
                logMessage('Scanning started. Monitoring for acoustic signals...', 'info');
                
                // Start analysis loop
                analyzeAudio();
                updateTimer();
                
            } catch (error) {
                logMessage('Failed to start scanning: ' + error.message, 'error');
                if (error.name === 'NotAllowedError') {
                    document.getElementById('permissionModal').classList.remove('hidden');
                }
            }
        }

        function stopScanning() {
            isScanning = false;
            
            // Clean up audio
            if (microphone) {
                microphone.disconnect();
                microphone = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            // Update UI
            const scanBtn = document.getElementById('scanBtn');
            scanBtn.textContent = 'üîç Start Scan';
            scanBtn.className = 'btn btn-primary';
            
            document.getElementById('statusText').textContent = 'Scan stopped';
            
            logMessage('Scanning stopped.', 'info');
        }

        function analyzeAudio() {
            if (!isScanning || !analyser) return;
            
            // Get frequency data
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            // Process the audio data
            processFrequencyData(dataArray);
            
            // Continue analysis
            requestAnimationFrame(analyzeAudio);
        }

        function processFrequencyData(dataArray) {
            const bufferLength = dataArray.length;
            const nyquist = SAMPLE_RATE / 2;
            
            // Update frequency bars
            updateFrequencyBars(dataArray);
            
            // Extract high-frequency spectrum (10kHz+)
            const highFreqSpectrum = extractHighFrequencySpectrum(dataArray);
            
            // Store in 5-second sliding window
            const now = Date.now();
            spectrumHistory.push({
                timestamp: now,
                spectrum: highFreqSpectrum
            });
            
            // Keep only last 5 seconds of data
            spectrumHistory = spectrumHistory.filter(frame => now - frame.timestamp <= ANALYSIS_WINDOW);
            
            // Calculate display metrics (for compatibility)
            const ultrasonicStart = Math.floor((ULTRASONIC_MIN / nyquist) * bufferLength);
            const ultrasonicEnd = Math.floor((ULTRASONIC_MAX / nyquist) * bufferLength);
            let ultrasonicPower = 0;
            let peakFreq = 0;
            let peakPower = 0;
            
            for (let i = ultrasonicStart; i < ultrasonicEnd; i++) {
                const power = dataArray[i];
                ultrasonicPower += power;
                if (power > peakPower) {
                    peakPower = power;
                    peakFreq = (i / bufferLength) * nyquist;
                }
            }
            ultrasonicPower /= (ultrasonicEnd - ultrasonicStart);
            
            // Store power history for visualization
            powerHistory.push(ultrasonicPower);
            if (powerHistory.length > 100) {
                powerHistory.shift();
            }
            
            // Update statistics
            updateStatistics(ultrasonicPower, peakFreq);
            
            // NEW: Simple pattern detection in 5s window
            detectRepeatedPatterns();
            
            // Update visualizations
            updatePowerChart();
            updateSpectrogram(dataArray);
        }
        
        function extractHighFrequencySpectrum(dataArray) {
            const nyquist = SAMPLE_RATE / 2;
            const minBin = Math.floor((MIN_FREQUENCY / nyquist) * dataArray.length);
            
            // Extract spectrum from 10kHz+ and normalize
            const highFreqData = dataArray.slice(minBin);
            
            // Downsample to 32 bins for pattern matching
            const targetBins = 32;
            const binSize = Math.floor(highFreqData.length / targetBins);
            const spectrum = [];
            
            for (let i = 0; i < targetBins; i++) {
                let binPower = 0;
                const start = i * binSize;
                const end = Math.min(start + binSize, highFreqData.length);
                
                for (let j = start; j < end; j++) {
                    binPower += highFreqData[j];
                }
                
                spectrum.push(binPower / (end - start));
            }
            
            return spectrum;
        }

        function updateFrequencyBars(dataArray) {
            const bars = document.querySelectorAll('.freq-bar');
            const step = Math.floor(dataArray.length / bars.length);
            
            bars.forEach((bar, index) => {
                const dataIndex = index * step;
                const height = Math.max(2, (dataArray[dataIndex] / 255) * 100);
                bar.style.height = height + 'px';
                
                // Color based on frequency range
                const freq = (dataIndex / dataArray.length) * (SAMPLE_RATE / 2);
                if (freq >= ULTRASONIC_MIN && freq <= ULTRASONIC_MAX) {
                    bar.style.background = '#ff4141'; // Red for ultrasonic
                } else if (freq > 20000) {
                    bar.style.background = '#ffaa00'; // Orange for high freq
                } else {
                    bar.style.background = '#00ff41'; // Green for normal
                }
                
                bar.style.opacity = 0.3 + (height / 100) * 0.7;
            });
        }

        function detectRepeatedPatterns() {
            // ÈúÄË¶ÅËá≥Â∞ë2ÁßíÁöÑÊï∞ÊçÆÊâçÂºÄÂßãÂàÜÊûê
            if (spectrumHistory.length < 40) { // ~2Áßí @ 20fps
                updateThreatLevel(0);
                return;
            }
            
            // Ê£ÄÊµãÈáçÂ§çÊ®°Âºè
            const patterns = findRepeatingPatterns();
            
            if (patterns.length > 0) {
                // ÊâæÂà∞ÈáçÂ§çÊ®°ÂºèÔºÅ
                const bestPattern = patterns[0]; // ÂèñÊúÄÂº∫ÁöÑÊ®°Âºè
                
                const detection = {
                    timestamp: new Date().toLocaleTimeString(),
                    type: 'repeated-pattern',
                    pattern: bestPattern.type,
                    repeats: bestPattern.count,
                    confidence: bestPattern.confidence,
                    power: bestPattern.avgPower,
                    threatLevel: calculateSimpleThreatLevel(bestPattern)
                };
                
                if (detection.threatLevel > 3) { // Âè™ËÆ∞ÂΩï‰∏≠Á≠â‰ª•‰∏äÂ®ÅËÉÅ
                    detectionCount++;
                    detectionLog.push(detection);
                    logDetection(detection);
                }
                
                updateThreatLevel(detection.threatLevel);
            } else {
                // Ê≤°ÊâæÂà∞ÊòéÊòæÈáçÂ§çÊ®°Âºè
                updateThreatLevel(0);
            }
        }
        
        function findRepeatingPatterns() {
            const patterns = [];
            const windowSize = 20; // ÊØè‰∏™Ê®°ÂºèÁâáÊÆµ1Áßí
            
            // Â¶ÇÊûúÂéÜÂè≤Êï∞ÊçÆ‰∏çÂ§üÔºåËøîÂõûÁ©∫
            if (spectrumHistory.length < windowSize * 2) return patterns;
            
            // ÊªëÂä®Á™óÂè£Êü•ÊâæÈáçÂ§ç
            for (let segmentLength = 10; segmentLength <= 30; segmentLength += 5) {
                if (spectrumHistory.length < segmentLength * 3) continue;
                
                const pattern = detectPatternInWindow(segmentLength);
                if (pattern) {
                    patterns.push(pattern);
                }
            }
            
            // ÊåâÁΩÆ‰ø°Â∫¶ÊéíÂ∫è
            patterns.sort((a, b) => b.confidence - a.confidence);
            return patterns;
        }
        
        function detectPatternInWindow(segmentLength) {
            const totalFrames = spectrumHistory.length;
            const maxSegments = Math.floor(totalFrames / segmentLength);
            
            if (maxSegments < 3) return null; // Ëá≥Â∞ëÈúÄË¶Å3‰∏™ÁâáÊÆµ
            
            // ÂàõÂª∫ÂèÇËÄÉÊ®°ÂºèÔºàÁ¨¨‰∏Ä‰∏™ÁâáÊÆµÔºâ
            const referenceSegment = spectrumHistory.slice(0, segmentLength);
            const referencePattern = createPatternSignature(referenceSegment);
            
            let matchCount = 0;
            let totalSimilarity = 0;
            let totalPower = 0;
            
            // Ê£ÄÊü•ÂêéÁª≠ÁâáÊÆµ
            for (let i = 1; i < maxSegments; i++) {
                const startIdx = i * segmentLength;
                const endIdx = Math.min(startIdx + segmentLength, totalFrames);
                
                if (endIdx - startIdx < segmentLength * 0.8) continue; // ÁâáÊÆµÂ§™Áü≠
                
                const segment = spectrumHistory.slice(startIdx, endIdx);
                const segmentPattern = createPatternSignature(segment);
                const similarity = calculatePatternSimilarity(referencePattern, segmentPattern);
                
                totalPower += segmentPattern.avgPower;
                
                if (similarity > PATTERN_THRESHOLD) {
                    matchCount++;
                    totalSimilarity += similarity;
                }
            }
            
            // Â¶ÇÊûúÊâæÂà∞Ë∂≥Â§üÁöÑÂåπÈÖç
            if (matchCount >= MIN_REPEATS - 1) { // -1 Âõ†‰∏∫Á¨¨‰∏Ä‰∏™ÊòØÂèÇËÄÉ
                return {
                    type: classifyPatternType(referencePattern),
                    count: matchCount + 1,
                    confidence: totalSimilarity / Math.max(matchCount, 1),
                    avgPower: totalPower / Math.max(matchCount, 1),
                    segmentLength: segmentLength
                };
            }
            
            return null;
        }
        
        function createPatternSignature(segment) {
            if (segment.length === 0) return null;
            
            // ËÆ°ÁÆóËøô‰∏™ÁâáÊÆµÁöÑÁâπÂæÅ
            let totalPower = 0;
            let peakPower = 0;
            const avgSpectrum = new Array(32).fill(0);
            
            segment.forEach(frame => {
                const framePower = frame.spectrum.reduce((sum, val) => sum + val, 0);
                totalPower += framePower;
                peakPower = Math.max(peakPower, framePower);
                
                frame.spectrum.forEach((val, idx) => {
                    avgSpectrum[idx] += val;
                });
            });
            
            // ÂΩí‰∏ÄÂåñ
            const avgPower = totalPower / segment.length;
            avgSpectrum.forEach((val, idx) => {
                avgSpectrum[idx] = val / segment.length;
            });
            
            // ËÆ°ÁÆóÈ¢ëË∞±ÂèòÂåñË∂ãÂäø
            const trend = calculateSpectralTrend(segment);
            
            return {
                avgSpectrum: avgSpectrum,
                avgPower: avgPower,
                peakPower: peakPower,
                trend: trend,
                length: segment.length
            };
        }
        
        function calculateSpectralTrend(segment) {
            if (segment.length < 3) return 'stable';
            
            const firstHalf = segment.slice(0, Math.floor(segment.length / 2));
            const secondHalf = segment.slice(Math.floor(segment.length / 2));
            
            const firstAvg = firstHalf.reduce((sum, frame) => {
                return sum + frame.spectrum.reduce((s, v) => s + v, 0);
            }, 0) / firstHalf.length;
            
            const secondAvg = secondHalf.reduce((sum, frame) => {
                return sum + frame.spectrum.reduce((s, v) => s + v, 0);
            }, 0) / secondHalf.length;
            
            const change = (secondAvg - firstAvg) / firstAvg;
            
            if (change > 0.2) return 'increasing';
            if (change < -0.2) return 'decreasing';
            return 'stable';
        }
        
        function calculatePatternSimilarity(pattern1, pattern2) {
            if (!pattern1 || !pattern2) return 0;
            
            // ÊØîËæÉÈ¢ëË∞±ÂàÜÂ∏É
            let spectrumSimilarity = 0;
            for (let i = 0; i < Math.min(pattern1.avgSpectrum.length, pattern2.avgSpectrum.length); i++) {
                const diff = Math.abs(pattern1.avgSpectrum[i] - pattern2.avgSpectrum[i]);
                const max = Math.max(pattern1.avgSpectrum[i], pattern2.avgSpectrum[i]);
                if (max > 0) {
                    spectrumSimilarity += 1 - (diff / max);
                }
            }
            spectrumSimilarity /= pattern1.avgSpectrum.length;
            
            // ÊØîËæÉÂäüÁéáÊ∞¥Âπ≥
            const powerDiff = Math.abs(pattern1.avgPower - pattern2.avgPower);
            const maxPower = Math.max(pattern1.avgPower, pattern2.avgPower);
            const powerSimilarity = maxPower > 0 ? (1 - powerDiff / maxPower) : 0;
            
            // ÊØîËæÉË∂ãÂäø
            const trendSimilarity = pattern1.trend === pattern2.trend ? 1 : 0;
            
            // ÁªºÂêàÁõ∏‰ººÂ∫¶
            return (spectrumSimilarity * 0.6 + powerSimilarity * 0.3 + trendSimilarity * 0.1);
        }
        
        function classifyPatternType(pattern) {
            if (!pattern) return 'unknown';
            
            const trend = pattern.trend;
            const avgPower = pattern.avgPower;
            
            if (avgPower > 150) {
                if (trend === 'increasing') return 'ascending-chirp';
                if (trend === 'decreasing') return 'descending-chirp';
                return 'high-power-pattern';
            } else if (avgPower > 80) {
                if (trend === 'increasing') return 'weak-up-sweep';
                if (trend === 'decreasing') return 'weak-down-sweep';
                return 'medium-pattern';
            }
            
            return 'low-level-pattern';
        }
        
        function calculateSimpleThreatLevel(pattern) {
            let threat = 0;
            
            // Âü∫‰∫éÈáçÂ§çÊ¨°Êï∞
            threat += Math.min(pattern.count * 1.5, 6);
            
            // Âü∫‰∫éÁΩÆ‰ø°Â∫¶
            threat += pattern.confidence * 3;
            
            // Âü∫‰∫éÂäüÁéá
            if (pattern.avgPower > 150) threat += 2;
            else if (pattern.avgPower > 100) threat += 1;
            
            // Âü∫‰∫éÊ®°ÂºèÁ±ªÂûã
            const typeMultipliers = {
                'ascending-chirp': 1.5,
                'descending-chirp': 1.5,
                'high-power-pattern': 1.3,
                'weak-up-sweep': 1.2,
                'weak-down-sweep': 1.2
            };
            
            const multiplier = typeMultipliers[pattern.type] || 1.0;
            threat *= multiplier;
            
            return Math.min(threat, 10);
        }

        function updateThreatLevel(level) {
            const threatLevel = document.getElementById('threatLevel');
            const threatFill = document.getElementById('threatFill');
            const threatScore = document.getElementById('threatScore');
            
            let color, text;
            
            if (level < 2) {
                color = '#00ff41';
                text = 'Safe';
            } else if (level < 5) {
                color = '#ffaa00';
                text = 'Low';
            } else if (level < 8) {
                color = '#ff8800';
                text = 'Medium';
            } else {
                color = '#ff4141';
                text = 'High';
            }
            
            threatLevel.textContent = text;
            threatLevel.style.color = color;
            threatFill.style.background = color;
            threatFill.style.width = (level * 10) + '%';
            threatScore.textContent = `Score: ${level.toFixed(1)}/10`;
        }

        function updateStatistics(avgPower, peakFreq) {
            document.getElementById('detectionCount').textContent = detectionCount;
            
            const avgPowerDb = avgPower > 0 ? 20 * Math.log10(avgPower / 255) : -Infinity;
            document.getElementById('avgPower').textContent = 
                isFinite(avgPowerDb) ? avgPowerDb.toFixed(1) : '-‚àû';
            
            document.getElementById('peakFreq').textContent = 
                peakFreq > 0 ? (peakFreq / 1000).toFixed(1) + ' kHz' : '--';
        }

        function updateTimer() {
            if (!isScanning || !startTime) return;
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('scanTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            setTimeout(updateTimer, 1000);
        }

        function updatePowerChart() {
            if (!powerCtx || powerHistory.length < 2) return;
            
            const canvas = powerCtx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            powerCtx.fillStyle = '#1e1e1e';
            powerCtx.fillRect(0, 0, width, height);
            
            // Draw grid
            powerCtx.strokeStyle = '#333';
            powerCtx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const y = (height / 4) * i;
                powerCtx.beginPath();
                powerCtx.moveTo(0, y);
                powerCtx.lineTo(width, y);
                powerCtx.stroke();
            }
            
            // Draw power line
            if (powerHistory.length > 1) {
                powerCtx.strokeStyle = '#00ff41';
                powerCtx.lineWidth = 2;
                powerCtx.beginPath();
                
                const step = width / (powerHistory.length - 1);
                
                powerHistory.forEach((power, index) => {
                    const x = index * step;
                    const y = height - (power / 255) * height;
                    
                    if (index === 0) {
                        powerCtx.moveTo(x, y);
                    } else {
                        powerCtx.lineTo(x, y);
                    }
                });
                
                powerCtx.stroke();
            }
        }

        function updateSpectrogram(dataArray) {
            if (!spectrogramCtx) return;
            
            const canvas = spectrogramCtx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            // Shift existing data left
            const imageData = spectrogramCtx.getImageData(1, 0, width - 1, height);
            spectrogramCtx.putImageData(imageData, 0, 0);
            
            // Draw new column
            const bufferLength = dataArray.length;
            const step = bufferLength / height;
            
            for (let y = 0; y < height; y++) {
                const dataIndex = Math.floor(y * step);
                const power = dataArray[dataIndex];
                
                // Convert to color
                const intensity = power / 255;
                const hue = (1 - intensity) * 240; // Blue to red
                const color = `hsl(${hue}, 100%, ${intensity * 50}%)`;
                
                spectrogramCtx.fillStyle = color;
                spectrogramCtx.fillRect(width - 1, height - y - 1, 1, 1);
            }
        }

        function logDetection(detection) {
            let message;
            
            if (detection.type === 'repeated-pattern') {
                message = `üö® REPEATED PATTERN: ${detection.pattern.toUpperCase().replace(/-/g, ' ')} | ` +
                         `Repeats: ${detection.repeats}x | ` +
                         `Confidence: ${(detection.confidence * 100).toFixed(1)}% | ` +
                         `Threat: ${detection.threatLevel.toFixed(1)}/10`;
            } else {
                message = `üö® DETECTED: ${detection.type.toUpperCase().replace(/-/g, ' ')} | ` +
                         `Confidence: ${(detection.confidence * 100).toFixed(1)}% | ` +
                         `Threat: ${detection.threatLevel.toFixed(1)}/10`;
            }
            
            logMessage(message, 'detection');
        }

        function logMessage(message, type = 'info') {
            const logContent = document.getElementById('logContent');
            const timestamp = new Date().toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
            
            // Keep only last 100 entries
            while (logContent.children.length > 100) {
                logContent.removeChild(logContent.firstChild);
            }
        }

        function clearLog() {
            document.getElementById('logContent').innerHTML = '';
            detectionLog = [];
            detectionCount = 0;
            powerHistory = [];
            document.getElementById('detectionCount').textContent = '0';
            logMessage('Log cleared.', 'info');
        }

        function exportLog() {
            if (detectionLog.length === 0) {
                logMessage('No detections to export.', 'warning');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `acoustic_scan_${timestamp}.txt`;
            
            let content = 'Acoustic FMCW Scanner - Detection Report\n';
            content += '='.repeat(60) + '\n\n';
            content += `Report Generated: ${new Date().toLocaleString()}\n`;
            content += `Total Detections: ${detectionLog.length}\n\n`;
            
            detectionLog.forEach((detection, index) => {
                content += `Detection #${index + 1}\n`;
                content += `  Time: ${detection.timestamp}\n`;
                content += `  Type: ${detection.type}\n`;
                content += `  Confidence: ${(detection.confidence * 100).toFixed(1)}%\n`;
                content += `  Power: ${detection.power.toFixed(1)}\n`;
                content += `  Threat Level: ${detection.threatLevel.toFixed(1)}/10\n`;
                content += '-'.repeat(40) + '\n';
            });
            
            // Download file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            logMessage(`Log exported to ${filename}`, 'info');
        }

        // Handle window resize
        window.addEventListener('resize', function() {
            setTimeout(initializeCanvases, 100);
        });
    </script>
</body>
</html>